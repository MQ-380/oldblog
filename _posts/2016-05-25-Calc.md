---
layout: post
title:  计算几何专题练习
date:   2016-5-25 16:50:00
categories: 算法分类
tags: 计算几何
---

# 计算几何专题练习

P.S：含有数学公式。。。如没有显示麻烦刷新，谢谢。

Contents：

* [1.基础题目](#1)

  ​    [1.1 uva11437](#1.1)

  ​    [1.2 uva11800](#1.2)

  ​    [1.3 uva11646](#1.3)

* [2.二维几何计算](#2)

    [2.1 uva11178 (EX.)](#2.1)

  ​


<h2 id = "1"> 1 基础题目 </h2>

<h3 id = "1.1"> UVA 11437 </h3>

1 本题主要运用到两个公式

   求三等分点的时候需要 定比分点公式  

   已知三条边求三角形面积用海伦公式。。。。。（全是初高中数学- -）

附上两个公式：

**定比分点**：O为原点，就可以求得D的坐标
$$
若 \overrightarrow{BD} = \lambda \overrightarrow{DC}，有\overrightarrow{OD} = \frac{\overrightarrow{OB}+\lambda \overrightarrow{OC} }{1+\lambda}
$$

**海伦公式**：
$$
S = \sqrt{p(p-a)(p-b)(p-c)}  \quad 其中 p = \frac{1}{2} (a+b+c) \quad a/b/c为三边边长
$$
2 主要思路

   a 已知三点求出三个三等分点的坐标

   b 利用三等分点的坐标求出之间连线的向量

   c 利用向量求交点（模板）

   d 交点求长度

   e 求三角形面积（注意四舍五入）

3 模板（利用一点和一个向量所得的直线的参数方程求，cross为叉积）

```cpp
Point crosspoint(Vector a,Vector b,Point af,Point bf){
    Vector u;
    u.make(bf,af);   //求BF-AF的向量
    double t = cross(b,u)/cross(a,b);   //求交点的参数
    Point k;     //交点
    k.x = af.x + t * a.x;
    k.y = af.y + t * a.y;
    return k;
}
```

4 代码

   

```cpp
#include <iostream>
#include <cmath>

using namespace std;

struct Point{
    double x,y;
};
struct Vector{
    double x,y;
    void make(Point a,Point b){
        x = b.x - a.x;
        y = b.y - a.y;
    }
};

double cross(Vector a,Vector b){
    return a.x*b.y - a.y*b.x;
}

Point crosspoint(Vector a,Vector b,Point af,Point bf){
    Vector u;
    u.make(bf,af);
    double t = cross(b,u)/cross(a,b);
    Point k;
    k.x = af.x + t * a.x;
    k.y = af.y + t * a.y;
    return k;
}

double distance(Point a,Point b){
    return sqrt((b.x-a.x)*(b.x-a.x)+(b.y-a.y)*(b.y-a.y));
}

int main(void){
    int t;
    cin>>t;
    Point a,b,c,d,e,f,p,q,r;
    while(t--){
        cin>>a.x>>a.y>>b.x>>b.y>>c.x>>c.y;
        d.x = (2*b.x+c.x)/3.0;
        d.y = (2*b.y+c.y)/3.0;
        e.x = (a.x+2*c.x)/3.0;
        e.y = (a.y+2*c.y)/3.0;
        f.x = (2*a.x+b.x)/3.0;
        f.y = (2*a.y+b.y)/3.0;
        Vector AD,CF,BE;
        AD.make(a,d);
        CF.make(c,f);
        BE.make(b,e);
        p = crosspoint(AD,BE,a,b);
        q = crosspoint(BE,CF,b,c);
        r = crosspoint(AD,CF,a,c);
        double RP,RQ,QP;
        RP = distance(r,p);
        RQ = distance(r,q);
        QP = distance(q,p);
        double S,pi;
        pi = (RP+RQ+QP)/2;
        S = sqrt(pi*(pi-QP)*(pi-RQ)*(pi-RP));
        long long Sans = ((int)(S+0.5)*10)/10;
        cout<<Sans<<endl;
    }
}
```

<h3 id = "1.2"> UVA 11800 </h3>

1 题意：

   就是给4个点判断这个四边形是什么四边形。。。。

2 陷阱

   四个点不一定按照逆时针或者顺时针可以ABCD标号的顺序来。。所以一开始就极角排序排定一下逆时针，排完序就可以ABCD的进行计算判断。

3 主要计算的数据

   四条边和四个角。。。主要还是四个边的向量和长度。。因为浮点数的原因如果用角判断会有误差。所以用边才是坠吼的

4 几个形状判断

   先判断90度。。有一个90度就进入矩形和正方形的判断。。。四条边都相等就是正方，否则是矩形。

   排除了正方之后，四条边相等就是菱形。。

   菱形排除完如果对边相等就是平行四边形。。。

   最后的坑就是梯形。。一开始陷入了同旁内角180度。。然后高相等。。。最后才想到直接判只要有一对平行（叉乘等于零）就好了。。。真是犯蠢了。。

5 代码

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#include <vector>

using namespace std;

struct Point{
    double x,y;
};
struct Vector{
    double x,y;
    void make(Point a,Point b){
        x = b.x - a.x;
        y = b.y - a.y;
    }
};

double cross(Vector a,Vector b){
    return a.x*b.y - a.y*b.x;
}

double intimes(Vector a,Vector b){
    return a.x*b.x + a.y*b.y;
}

double length(Vector a){
    return sqrt(a.x*a.x + a.y*a.y);
}
Point crosspoint(Vector a,Vector b,Point af,Point bf){
    Vector u;
    u.make(bf,af);
    double t = cross(b,u)/cross(a,b);
    Point k;
    k.x = af.x + t * a.x;
    k.y = af.y + t * a.y;
    return k;
}

double distance(Point a,Point b){
    return sqrt((b.x-a.x)*(b.x-a.x)+(b.y-a.y)*(b.y-a.y));
}

double cosangle(Vector a,Vector b){
    return intimes(a,b)/length(a)*length(b);
}
Point origin;
bool cmp(Point a,Point b){
    Vector A,B;
    A.make(origin, a);
    B.make(origin, b);
    return cross(A,B)<0;
}

double PTOL(Point p,Point a,Point b){
    Vector v1,v2;
    v1.make(a,b);
    v2.make(a,p);
    return fabs(cross(v1,v2)/length(v1));
}

int main(void){
    int t;
    cin>>t;
    int cnt = 0;
    while(t--){
        vector<Point> ref;
        ref.clear();
        cnt++;
        Point A,B,C,D;
        cin>>A.x>>A.y>>B.x>>B.y>>C.x>>C.y>>D.x>>D.y;
        ref.push_back(A);
        ref.push_back(B);
        ref.push_back(C);
        ref.push_back(D);
        int miny = 10000000;
        int minx = 10000000;
        int flag = 0;
        for(int j=0;j<4;j++){
            if(ref[j].y<miny){
                miny = ref[j].y;
                minx = ref[j].x;
                flag = j;
            }else if (ref[j].y == miny && ref[j].x < minx){
                miny = ref[j].y;
                minx = ref[j].x;
                flag = j;
            }
        }
        origin = ref[flag];
        swap(ref[0],ref[flag]);
        sort(ref.begin()+1,ref.end(),cmp);
        A = ref[0];
        B = ref[1];
        C = ref[2];
        D = ref[3];
        //判断90
        Vector AB,BC,CD,DA;
        AB.make(A,B);
        BC.make(B,C);
        CD.make(C,D);
        DA.make(D,A);
        double JA,JB,JC,JD;
        JA = cosangle(AB,DA);
        JB = cosangle(AB,BC);
        JC = cosangle(BC,CD);
        JD = cosangle(CD,DA);
        double LA,LB,LC,LD;
        LA = length(AB);
        LB = length(BC);
        LC = length(CD);
        LD = length(DA);
        cout<<"Case "<<cnt<<": ";
        if(JA==0 &&  JB==0 &&  JC==0 && JD==0){
            if(LA==LB && LB==LC && LC==LD && LD==LA){
                cout<<"Square"<<endl;
            }else{
                cout<<"Rectangle"<<endl;
            }
        }else if(LA == LB && LB==LC && LC==LD && LD==LA){
            cout<<"Rhombus"<<endl;
        }else if(LA==LC && LB == LD){
            cout<<"Parallelogram"<<endl;
        }else if(cross(AB,CD) == 0 || cross(DA,BC) == 0){
                cout<<"Trapezium"<<endl;
        }else{
            cout<<"Ordinary Quadrilateral"<<endl;
        }
    }
    return 0;
}
```


<h3 id = "1.3"> UVA 11646 </h3>

1 题意：

  造体育场，给定比例求长宽。。

2 解法：

  还是缺乏高中数学知识 - -。。 

 已知弦长a，半径R，求弧长l的公式：
$$
l = 2Rarcsin(\frac{a}{2R})
$$

3 坑：

   一如既往地只要题目简单就会卡在输入输出上。。。搞了好久。。

4 代码：

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#include <vector>
#include <string>
#include <sstream>

using namespace std;

int main(void){
    double a,b;
    int cnt = 0;
    string c;
    while(getline(cin,c)){
        stringstream ss(c);
        ss>>a;
        cnt++;
        char t;
        ss>>t;
        ss>>b;
        double x = 400.0/(2.0*sqrt(a*a+b*b)*atan(b/a)+2.0*a);
        printf("Case %d: %.10lf %.10lf\n",cnt,a*x,b*x);
    }
    return 0;
}
```





<h2 id = "2"> 2 二维几何计算 </h2>

<h3 id = "2.1"> UVA11178 </h3>

1 题意

   有一个数学定理。。。角的三等分线相交出来的一个三角形是一个等边三角形。。。

  其实这道题和这个等边三角形并没有什么关系。。

2 题解

   因为点来的方法都一样，所以只要写出来一个函数就ok。。。怎么求这个点呢？

   先求出一个大三角形的角，然后求三分之一角度用底边旋转出来，就可以等到这条边然后再用另一边同样的方法转出来另一条线，两个相交的交点就是小三角形的一个点。。

3 模板

   前面没有出现的就是怎么样旋转一个向量一定的角度得到另一个向量。。又是高中数学问题

  公式就不写了。。直接给函数吧。。

```cpp
Vector Rotate(Vector a,double rad){
    return (Vector){a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad)};
}
```

 4 代码

因为和前面几题并在一起写了。。。所以应该会有很多冗余的函数。。

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#include <vector>
#include <string>
#include <sstream>

using namespace std;


struct Point{
    double x,y;
};
struct Vector{
    double x,y;
    void make(Point a,Point b){
        x = b.x - a.x;
        y = b.y - a.y;
    }
};

double cross(Vector a,Vector b){
    return a.x*b.y - a.y*b.x;
}

double intimes(Vector a,Vector b){
    return a.x*b.x + a.y*b.y;
}

double length(Vector a){
    return sqrt(a.x*a.x + a.y*a.y);
}
Point crosspoint(Vector a,Vector b,Point af,Point bf){
    Vector u;
    u.make(bf,af);
    double t = cross(b,u)/cross(a,b);
    Point k;
    k.x = af.x + t * a.x;
    k.y = af.y + t * a.y;
    return k;
}

double distance(Point a,Point b){
    return sqrt((b.x-a.x)*(b.x-a.x)+(b.y-a.y)*(b.y-a.y));
}

double cosangle(Vector a,Vector b){
    return intimes(a,b)/(length(a)*length(b));
}
Point origin;
bool cmp(Point a,Point b){
    Vector A,B;
    A.make(origin, a);
    B.make(origin, b);
    return cross(A,B)<0;
}

double PTOL(Point p,Point a,Point b){
    Vector v1,v2;
    v1.make(a,b);
    v2.make(a,p);
    return fabs(cross(v1,v2)/length(v1));
}
//将向量逆时针旋转弧度为a的角度
Vector Rotate(Vector a,double rad){
    return (Vector){a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad)};
}

Point GETCROSS(Point A,Point B,Point C){
    Vector v1,tmp;
    v1.make(B,C);
    tmp.make(B,A);
    double rad = acos(cosangle(tmp,v1));
    v1 = Rotate(v1,rad/3.0);
    
    Vector v2;
    v2.make(C,B);
    tmp.make(C,A);
    double rad2 = acos(cosangle(tmp,v2));
    v2 = Rotate(v2,-rad2/3.0);
    return crosspoint(v1,v2,B,C);
}

int main(void){
    int T;
    cin>>T;
    while(T--){
        Point A,B,C;
        cin>>A.x>>A.y>>B.x>>B.y>>C.x>>C.y;
        Point D,E,F;
        D = GETCROSS(A,B,C);
        E = GETCROSS(B,C,A);
        F = GETCROSS(C,A,B);
        printf("%.6lf %.6lf %.6lf %.6lf %.6lf %.6lf\n",D.x,D.y,E.x,E.y,F.x,F.y);
    }
    return 0;
}

```